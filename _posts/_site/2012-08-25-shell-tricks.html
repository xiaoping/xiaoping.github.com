<h2 id='id32'>编码规范</h2>

<p>1 对命令的返回值进行判断 2 临时文件采用脚本名加PID标识并清理 <br />3 function内的局部变量使用local限定符 <br />4 显式函数返回return脚本退出exit <br />5 变量名用<code>${}</code>括起来 <br />6 命令替换使用<code>$()</code>而不是反引号 <br />7 将变量写在脚本头或者独立成配置</p>

<h2 id='id33'>参数处理</h2>

<ul>
<li>直接使用$0,$1……，$@，$#</li>

<li>通过eval赋值</li>
</ul>
<div>
  <pre><code class='bash'>function_test key1=value1 key2=value2
在function_test内部使用
eval “$@” 
解析参数输入,后面就可以通过$key1,$key2使用了</code></pre>
</div>
<ul>
<li>通过set改变环境变量</li>
</ul>
<div>
  <pre><code class='bash'>string=“var1 var2 var3” 
set -- $string</code></pre>
</div>
<p>则可以通过$1的值为var1，$#的值为3。这种方法改变了环境变量，慎重。或者在subshell中使用</p>

<ul>
<li>getopts</li>
</ul>

<h2 id='subshell'>理解subshell/子进程</h2>

<p>子进程可以继承父进程的环境变量 <div>
  <pre><code class='bash'>num=0
cat file | while read line ; do
  $num++
done
echo $num</code></pre>
</div></p>

<p>和</p>
<div>
  <pre><code class='bash'>num=0
While read line ; do
  let &quot;num ++&quot;
Done &lt; file</code></pre>
</div>
<p>“|”创建了一个子进程，无法将变量传给父shell</p>

<h2 id='here'>文本使用here文档</h2>
<div>
  <pre><code class='bash'>/usr/sbin/sendmail -t &lt;&lt;-End_mail
    Subject:$mail_subject
    From:$mail_from
    To:$mail_to
    Return-Path:$mail_return_path
    Reply-to:$mail_reply_to
    `cat -`
End_mail</code></pre>
</div>
<p>利用End_mail前面的”-”可以使用tab进行缩进，保持脚本可读</p>

<h2 id='id34'>避免常见陷阱</h2>

<ol>
<li>避免shell参数个数限制</li>
</ol>
<div>
  <pre><code class='bash'>xargs</code></pre>
</div>
<ol>
<li>避免test测试错误</li>
</ol>
<div>
  <pre><code class='bash'>[ &quot;X$var&quot; = Xsomething ]</code></pre>
</div>
<p>3. 避免变量未初始化错误</p>
<div>
  <pre><code class='bash'>${var:-0}</code></pre>
</div>
<ol>
<li>避免cd引起路径错误</li>
</ol>
<div>
  <pre><code class='bash'>() #或者
&amp;&amp; #屏蔽</code></pre>
</div>
<p>5. 更加安全的使用$@</p>
<div>
  <pre><code class='bash'>${1+”$@”}</code></pre>
</div>
<p>6. 避免进程异常退出</p>
<div>
  <pre><code class='bash'>trap 'rm tempfle' EXIT</code></pre>
</div>
<ol>
<li>crontab中的元字符</li>
</ol>
<div>
  <pre><code class='bash'>%</code></pre>
</div>
<ol>
<li>规避xargs的默认分割行为</li>
</ol>
<div>
  <pre><code class='bash'>find . Type f -mtime +7 -print 0 | xargs -0 rm</code></pre>
</div>
<p>9. 避免拷贝错误：</p>
<div>
  <pre><code class='bash'>cp file dir/ ## 一定记住最后的“/”</code></pre>
</div>
<h2 id='id35'>理解文件描述符</h2>
<div>
  <pre><code class='bash'>&gt;file 2&gt;&amp;1 #和
2&gt;&amp;1 &gt;file ##的区别为: shell从左到右读取参数

&gt;file 2&gt;&amp;1 ##将标准输出和标准错误重定向到file
2&gt;&amp;1 &gt;file ##将标准输出重定向到file，标准错误仍然为屏幕

-------------------
&amp;&gt;/dev/null ##等价于 
&gt;/dev/null 2&gt;&amp;1 ##使用前者。</code></pre>
</div>
<h2 id='id36'>命令分组</h2>
<div>
  <pre><code class='bash'>(command1;command2) &gt;log ## 子shell中运行命令组
{command1 ; command2 ;} &gt;/dev/null ## 当前shell中运行命令组
((command1;command2)&amp; ##多个命令后台运行</code></pre>
</div>
<h2 id='id37'>字串替换</h2>

<p>说明： #前%后，控制字串截取方式 实例：当前目录下有如下文件</p>

<p><code>host.new offline.new online.new rd.new wugui64.new xferlog.new</code></p>

<p>需要将后缀.new去掉</p>
<div>
  <pre><code class='bash'>for x in `ls *new`; do
  old_name=${x%.new} 
  mv $x $old_name
done</code></pre>
</div>
<h2 id='id38'>进程替换</h2>

<p><code>&lt;()</code> 将进程的输出替换为文本做标准输入</p>
<div>
  <pre><code class='bash'>vimdiff &lt;() &lt;()</code></pre>
</div>
<p>同时从文件和标准输入获取： <div>
  <pre><code class='bash'>cat file | diff - file2 ## -代表标准输入</code></pre>
</div></p>

<p>另外一种方式</p>
<div>
  <pre><code class='bash'>diff &lt;(cat file) file2</code></pre>
</div>
<p>实例：diff两台服务器的同一个配置文件 <div>
  <pre><code class='bash'>Vimdiff &lt;(ssh server1 cat conf) &lt;(ssh server2 cat conf)</code></pre>
</div></p>

<h2 id='wget'>wget使用</h2>

<ol>
<li>不要随便修改-t -T选项的设置</li>

<li>限制使用<code>*</code>，失败后返回值仍为0</li>

<li>注意加-c和不加-c的程序行为</li>

<li>从线上下载数据要加&#8211;limit-rate=10M</li>
</ol>

<h2 id='ssh'>ssh的使用</h2>

<p>非交互使用ssh，最好加-n参数</p>

<p>file文件的内容为：</p>
<div>
  <pre><code class='bash'>server1
server2</code></pre>
</div><div>
  <pre><code class='bash'>while read server ; do
   ssh -n $server ‘uname -r’
done &lt; file</code></pre>
</div>
<p>远程使用vim，加-t参数，分配tty 超时，重试参数 <div>
  <pre><code class='bash'>-o ConnectTimeout=20 -o ConnectionAttempts=4</code></pre>
</div></p>

<p>使用rsync前，加&#8211;dry-run参数 scp加-p参数，保持文件时间戳一致，利用浏览器缓存</p>

<h2 id='find'>find的使用</h2>

<p>1. 排除目录 <div>
  <pre><code class='bash'>find abs -path &quot;abs/zllib&quot; -prune -o -name &quot;*.sh&quot; –print</code></pre>
</div></p>

<p>2. 精确判断时间 <div>
  <pre><code class='bash'>touch –t time time_file
find –newer time_file</code></pre>
</div></p>

<p>3. 运行命令 <div>
  <pre><code class='bash'>-exec command {} \; # {}代表find找到的，作为command的参数</code></pre>
</div></p>

<h2 id='id39'>分离会话</h2>

<p>1 nohup</p>
<div>
  <pre><code class='bash'>nohup command &amp; ## 需要注意的一点是如果command中包含多个命令，不要使用&amp;&amp;连接，需要使用;</code></pre>
</div>
<p>2 disown：命令敲下去发现忘记nohup了怎么办？使用disown补救 3 screen：在wiki中搜一下</p>

<h2 id='id40'>创建安全和可维护的脚本</h2>

<p>1 供其他进程使用的文件生成时 采用更名再mv的方式 如 <div>
  <pre><code class='bash'>file &lt;/dev/null
:&gt;file</code></pre>
</div></p>

<p>2 将函数和配置独立成单独的脚本</p>

<p>3 将不同服务器需要差异对待的变量提取成单独的配置文件</p>

<p>4 日志打印必须包含脚本名<code>basename</code>和时间</p>

<p>5 每步骤必须校验返回值</p>

<p>6 脚本中避免使用<code>*</code></p>

<p>7 保持缩进4个空格</p>

<p>8 过长的命令按照<code>|</code>折行</p>

<p>9 创建目录使用<code>mkdir –p</code></p>

<p>10 如果采用后台运行一定要wait： <code>( command1 ; command2 ) &amp; wait</code></p>

<p>11 对于需要获取命令输出的命令需要将<code>stderr</code>屏蔽到<code>/dev/null</code></p>

<p>12 抽离公共逻辑作为函数或者代码片段（导入变量）</p>

<p>13 保证互斥和脚本实例唯一性</p>

<h2 id='id41'>参考资料</h2>

<ol>
<li><a href='http://tldp.org/LDP/abs/html/'>Abs</a> &#8211; advanced bash scripting guide</li>

<li><a href='http://docstore.mik.ua/orelly/unix/upt/index.htm'>unix power tools</a> &#8211; unix超级工具上、下</li>
</ol>